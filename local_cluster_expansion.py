"""
local cluster expansion code for LiCoO2
solves for local ECI using the least squares method described in "Linear-programming method for obtaining efFective cluster interactions in alloys
from total-energy calculations: Application to the fcc Pd-V system" G. D. Garbulsky and G. Ceder, 1995
"""

import numpy as np
from scipy.optimize import minimize
import sys

atom_types = ([["Li", "Vac"], [-1, 1]])


file_list = np.array([])
dft_activation_energies = np.array([])
number_of_sites = 10  # magic number, yay!
dft_configurations = np.array([np.zeros(number_of_sites)])
filename = "eci_normcons_LCE"
# energyies of the lowest and highest concentration states
reference_energy = [-76514.414238106393223, -76398.702259132575970]
# energy from adding a single Li ion
Li_unit_energy = (reference_energy[0] -
                  reference_energy[1]) / (number_of_sites)
# loads structures,energies and directory numbers from file generated by running do-all sturcture-getter in a cluster expansion directory
data = np.loadtxt(filename)
for lin in data:  # Each lin is a line in the file containing the occupancies, the energy of  the state and the case directory
    file_list = np.append(file_list, lin[-1])
    # -reference_energy[1]-list(lin[:-2]).count(atom_types[1][0])*Li_unit_energy))#energies per cell,not per atom site
    dft_activation_energies = np.append(dft_activation_energies, (lin[-2]))
    dft_configurations = np.append(dft_configurations, [lin[:-2]], axis=0)
# throwing away the nearest neighbour atom -always assumed empty
dft_configurations = np.array(dft_configurations[1:])
dft_activation_energies = dft_activation_energies

# hard coded, depends on which clusters are chosen
multiplicities = np.array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])
local_eci = np.zeros(len(multiplicities))
# np.linalg.lstsq(dft_configurations,dft_activation_energies)


# the list of polynomials multiplying each eci
average_occupancy = [np.zeros(len(multiplicities))]
for config in dft_configurations:
  x = [1, sum(config[1:]), (config[1]), (config[3]), (config[4]), (config[7]), (config[5]), (config[8]), (config[6]), (config[9]), config[2], config[6] * config[9],
       (config[4] * config[1]), (config[3] * config[7]), (config[4] * config[5] * config[6]), (config[7] * config[8] * config[9]), config[1] * config[2] * config[3],
       config[5]*config[2]*config[8],(config[5]*config[9]), (config[8]*config[6]),(config[5]*config[1]), (config[8]*config[3]),(config[2]*config[4]), (config[2]*config[7]),
       (config[5]*config[6]), (config[8]*config[9]),(config[5]*config[4]), (config[8]*config[7]),(config[2]*config[1]), (config[2]*config[3]),(config[2]*config[1]*config[4]),
       (config[2]*config[3]*config[7]),(config[5]*config[4]*config[1]), (config[8]*config[7]*config[3]),(config[5]*config[6]*config[9]), (config[8]*config[9]*config[6]),
       (config[1]*config[3]),(config[4]*config[6]), (config[7]*config[9]), (config[1]*config[4] * config[5] * config[6]), (config[3]*config[7] * config[8] * config[9]),
       config[5] * config[1] * config[2] * config[3] * config[6], config[2]*config[8],  config[5] * config[8], config[5] * config[4] *config[1] * config[2],
       config[5] * config[6] *config[9] * config[8], config[2] * config[3] *config[7] * config[8]]

  average_occupancy = np.append(average_occupancy, [x], axis=0)

def minimizer(eci):  # this is what needs to be minimized -it is like your chi square
  return sum(np.square(dft_activation_energies - np.dot(average_occupancy[1:], eci)))


# does least square fitting of the minimizer function with respect to the eci input
fit = minimize(minimizer, local_eci, method='Powell') #Powell,BFGS
# print dft_activation_energies, np.dot(average_occupancy[1:],fit.x)

print fit


for index in range(len(fit.x)): #to print the ECIs
  print round(fit.x[index], 10)

cross_validation_score = (fit.fun / len(dft_configurations))**(0.5)
print "CRV is: "+str(cross_validation_score)




test_config = np.array([1, 1, 1, 1, -1, 1, 1, 1, 1, 1])
cluster_vector = [1, sum(test_config[1:]), (test_config[1]), (test_config[3]), (test_config[4]), (test_config[7]), (test_config[5]), (test_config[8]), (test_config[6]), (test_config[9]), test_config[2], test_config[6] * test_config[9],
       (test_config[4] * test_config[1]), (test_config[3] * test_config[7]), (test_config[4] * test_config[5] * test_config[6]), (test_config[7] * test_config[8] * test_config[9]), test_config[1] * test_config[2] * test_config[3],test_config[5]*test_config[2]*test_config[8],(test_config[5]*test_config[9]), (test_config[8]*test_config[6]),(test_config[5]*test_config[1]), (test_config[8]*test_config[3]),(test_config[2]*test_config[4]), (test_config[2]*test_config[7]),(test_config[5]*test_config[6]), (test_config[8]*test_config[9]),(test_config[5]*test_config[4]), (test_config[8]*test_config[7]),(test_config[2]*test_config[1]), (test_config[2]*test_config[1]),(test_config[2]*test_config[1]*test_config[4]), (test_config[2]*test_config[3]*test_config[7]),(test_config[5]*test_config[4]*test_config[1]), (test_config[8]*test_config[7]*test_config[3]),(test_config[5]*test_config[6]*test_config[9]), (test_config[8]*test_config[9]*test_config[6]),(test_config[1]*test_config[3]),(test_config[4]*test_config[6]), (test_config[7]*test_config[9])]
# test_energy=reference_energy[1]+list(test_config).count(atom_types[1][0])*Li_unit_energy+np.dot(cluster_vector,fit.x)
test_energy = np.dot(cluster_vector, fit.x)
first_test_energy = test_energy
# cell_energy=test_energy+
print "test energy 01 is:" +str(test_energy)

test_config = np.array([1, 1, -1, 1, 1, 1, 1, 1, 1, 1])


cluster_vector = [1, sum(test_config[1:]), (test_config[1]), (test_config[3]), (test_config[4]), (test_config[7]), (test_config[5]), (test_config[8]), (test_config[6]), (test_config[9]), test_config[2], test_config[6] * test_config[9],
       (test_config[4] * test_config[1]), (test_config[3] * test_config[7]), (test_config[4] * test_config[5] * test_config[6]), (test_config[7] * test_config[8] * test_config[9]), test_config[1] * test_config[2] * test_config[3],test_config[5]*test_config[2]*test_config[8],(test_config[5]*test_config[9]), (test_config[8]*test_config[6]),(test_config[5]*test_config[1]), (test_config[8]*test_config[3]),(test_config[2]*test_config[4]), (test_config[2]*test_config[7]),(test_config[5]*test_config[6]), (test_config[8]*test_config[9]),(test_config[5]*test_config[4]), (test_config[8]*test_config[7]),(test_config[2]*test_config[1]), (test_config[2]*test_config[1]),(test_config[2]*test_config[1]*test_config[4]), (test_config[2]*test_config[3]*test_config[7]),(test_config[5]*test_config[4]*test_config[1]), (test_config[8]*test_config[7]*test_config[3]),(test_config[5]*test_config[6]*test_config[9]), (test_config[8]*test_config[9]*test_config[6]),(test_config[1]*test_config[3]),(test_config[4]*test_config[6]), (test_config[7]*test_config[9])]
# test_energy=reference_energy[1]+list(test_config).count(atom_types[1][0])*Li_unit_energy+np.dot(cluster_vector,fit.x)
test_energy = np.dot(cluster_vector, fit.x)

print "test energy 02 is: " +str(test_energy)

print "diff is: " +str(test_energy-first_test_energy)


